# 第一章 大数据概述

## （一）三次信息化浪潮

| 信息化浪潮 | 发生时间 | 标志 | 解决的问题 | 代表企业 |
|------------|----------|------|------------|----------|
| 第一次浪潮 | 1980年前后 | 个人计算机 | 信息处理 | Intel、AMD、IBM、苹果、微软、联想、戴尔、惠普等 |
| 第二次浪潮 | 1995年前后 | 互联网 | 信息传输 | 雅虎、谷歌、阿里巴巴、百度、腾讯等 |
| 第三次浪潮 | 2010年前后 | 物联网、云计算和大数据 | 信息爆炸 | 亚马逊、谷歌、IBM、VMWare、Palantir、Hortonworks、Cloudera、阿里云等 |

## （二）人类社会数据产生方式的3个阶段

1. **运营式系统阶段**
   - 数据库的出现使数据管理的复杂度大大降低
   - 数据往往伴随着一定的运营活动而产生并记录在数据库中
   - 数据的产生方式是被动的

2. **用户原创内容阶段**
   - 数据爆发产生于Web2.0时代
   - Web2.0时代的最重要标志就是用户原创内容
   - 智能手机等移动设备加速内容产生
   - 数据产生方式是主动的

3. **感知式系统阶段**
   - 感知式系统的广泛使用
   - 人类社会数据量第三次大的飞升最终导致了大数据的产生

## （三）大数据的3个发展阶段

1. **第一阶段：萌芽期**
   - 时间：20世纪90年代至21世纪初
   - 内容：随着数据挖掘理论和数据库技术的逐步成熟，一批商业智能工具和知识管理技术开始被应用，如数据仓库、专家系统、知识管理系统等

2. **第二阶段：成熟期**
   - 时间：21世纪前10年
   - 内容：Web2.0应用迅猛发展，非结构化数据大量产生，传统处理方法难以应对，带动了大数据技术的快速突破，大数据解决方案逐渐走向成熟，形成了并行计算与分布式系统两大核心技术，谷歌的GFS和MapReduce等大数据技术受到追捧，Hadoop平台开始大行其道

3. **第三阶段：大规模应用期**
   - 时间：2010年以后
   - 内容：大数据应用渗透各行各业，数据驱动决策，信息社会智能化程度大幅度提高

## （四）大数据4V概念

1. 数据量大
2. 数据类型繁多
3. 处理速度快
4. 价值密度低

## （五）数据存储单位之间的换算关系

| 单位 | 换算关系 |
|------|----------|
| Byte | 1 Byte = 8 bit |
| KB | 1 KB = 1024 Byte |
| MB | 1 MB = 1024 KB |
| GB | 1 GB = 1024 MB |
| TB | 1 TB = 1024 GB |
| PB | 1 PB = 1024 TB |
| EB | 1 EB = 1024 PB |
| ZB | 1 ZB = 1024 EB |

## （六）大数据对科学研究的影响

1. 第一种范式：实验科学
2. 第二种范式：理论科学
3. 第三种范式：计算科学
4. 第四种范式：数据密集型科学

## （七）大数据对思维方式的影响

1. 全样而非抽样
2. 效率而非精准
3. 相关而非因果

## （八）大数据技术的不同层面及其功能

1. **数据采集与预处理层面**
   - 功能：利用ETL工具将分布的、异构数据源中的数据，如关系数据、平面数据文件等，抽取到临时中间层后进行清洗、转换、集成，最后加载到数据仓库或数据集市中，成为联机分析处理、数据挖掘的基础；也可以利用日志采集工具（如Flume、Kafka等）把实时采集的数据作流计算系统的输入，进行实时处理分析

2. **数据存储和管理层面**
   - 功能：利用分布式文件系统、数据仓库、关系数据库、NoSQL数据库、云数据库等，实现对结构化、半结构化和非结构化海量数据的存储和管理

3. **数据处理与分析层面**
   - 功能：利用分布或并行编程模型和计算框架，结合机器学习和数据挖掘算法，实现对海量数据的处理和分析；对分析结果进行可视化呈现，帮助人们更好地理解数据、分析数据

4. **数据安全和隐私保护层面**
   - 功能：在从大数据中挖掘潜在的巨大商业价值和学术价值的同时，构建隐私数据保护体系和数据安全体系，有效保护个人隐私和数据安全

## （九）大数据计算模式及其代表产品

（内容待补充）

## （十）大数据产业的6个层次

1. IT基础设施层
2. 数据源层
3. 数据管理层
4. 数据分析层
5. 数据平台层
6. 数据应用层

## （十一）大数据与云计算、物联网

1. **云计算3种典型服务模型：**
   - IaaS（基础设施即服务）
   - PaaS（平台即服务）
   - SaaS（软件即服务）

2. **云计算3种方式：**
   - 公有云
   - 私有云
   - 混合云

3. **云计算的关键技术**
   - 虚拟化
   - 分布式存储
   - 分布式计算
   - 多租户

## （十二）物联网体系架构

（内容待补充）

## （十三）大数据与云计算、物联网的关系

（内容待补充）

# 第二章 大数据处理架构Hadoop

## （一）Hadoop的特性

- 高可靠性
- 高效性
- 高可扩展性
- 高容错性
- 成本低
- 运行在Linux平台上
- 支持多种编程语言

## （二）Hadoop两个版本区别

Apache Hadoop版本分为两代，第一代Hadoop称为Hadoop 1.0，第二代Hadoop称为Hadoop2.0。第一代Hadoop包含0.20.x、0.21.x和0.22.x三大版本，其中，0.20.x最后演化成1.0.x，变成了稳定版，而0.21.x和0.22.x则增加了HDFS HA等重要的新特性。第二代Hadoop包含0.23.x和2.x两大版本，它们完全不同于Hadoop 1.0，是一套全新的架构，均包含HDFS Federation和YARN(Yet Another Resource Negotiator)两个系统。

## （三）Hadoop生态系统

（内容待补充）

# 第三章 分布式文件系统HDFS

## 3.1 分布式文件系统

### 3.1.2 分布式文件系统的结构

1. 分布式文件系统在物理结构上是由计算机集群中的多个节点构成。一类叫"主节点"，或者也被称为"名称节点"（NameNode）；另一类叫"从节点"，或者也被称为"数据节点"（DataNode）。
2. 名称节点负责文件和目录的创建、删除和重命名等，同时管理着数据节点和文件块的映射关系，因此客户端只有访问名称节点才能找到请求的文件块所在的位置，进而到相应位置读取所需文件块。
3. 数据节点负责数据的存储和读取，在存储时，由名称节点分配存储位置，然后由客户端把数据直接写人相应数据节点；在读取时，客户端从名称节点获得数据节点和文件块的映射关系，然后就可以到相应位置访问文件块。数据节点也要根据名称节点的命令创建、删除数据块和冗余复制。

## 3.2 HDFS简介

1. **HDFS要实现的目标：**
   - 兼容廉价的硬件设备
   - 流数据读写
   - 大数据集
   - 简单的文件模型
   - 强大的跨平台兼容性
   - 不适合低延迟数据访问
   - 无法高效存储大量小文件
   - 不支持多用户写入及任意修改文件

## 3.3 HDFS的相关概念

### 3.3.1 块

1. 默认块的大小：64MB
2. **HDFS采用抽象的块概念的好处：**
   - 支持大规模文件存储
   - 简化系统设计
   - 适合数据备份

### 3.3.2 名称节点和数据节点

1. 名称节点负责管理分布式文件系统的命名空间，保存了两个核心的数据结构，即FsImage和EditLog
2. 数据节点是分布式文件系统HDFS的工作节点，负责数据的存储和读取，会根据客户端或者名称节点的调度来进行数据的存储和检索，并向名称节点定期发送自己所存储的块的列表。

### 3.3.3 第二名称节点

1. 两方面功能：
   - 可以完成EditLog与FsImage的合并操作，减少EditLog文件的大小，缩短名称节点的重启时间
   - 可以作为名称节点的"检查点"，保持名称节点中的元数据信息

## 3.4 HDFS体系结构

### 3.4.1 概述

HDFS采用的是主从（Master/Slave）结构模型，一个HDFS集群包括一个名称节点和若干个数据节点。

### 3.4.5 HDFS体系结构的局限性

局限性：
1. 命名空间的限制
2. 性能的瓶颈
3. 隔离问题
4. 集群的可用性

## 3.5 HDFS的存储原理

### 3.5.1 数据的冗余存储

HDFS的存储方式：多副本方式对数据进行冗余存储，默认的冗余复制因子是3。

### 3.5.3 数据错误与恢复

3种错误情形出现会有相应的机制检测数据错误和进行自动恢复：
1. 名称节点出错
2. 数据节点出错
3. 数据出错

## 3.6 HDFS的数据读写过程

### 3.6.1 读数据的过程

（参考P53 图3-8）

### 3.6.2 写数据的过程

（内容待补充）

# 第四章 分布式数据库HBase

## 4.1概述

### （一）BigTable具备以下特性：

- 支持大规模海量数据
- 分布式并发数据处理效率极高
- 易于扩展且支持动态伸缩
- 适用于廉价设备
- 适用于读操作不适合写操作

### （二）HBase和BigTable的底层技术对应关系

| 项目 | 文件存储系统 | 海量数据处理 | 协同服务管理 |
|------|--------------|--------------|--------------|
| BigTable | GFS | MapReduce | Chubby |
| HBase | HDFS | HadoopMapReduce | ZooKeeper |

### （三）HBase与传统数据库的对比分析

HBase与传统数据库的区别主要体现在以下几个方面：

1. **数据类型**：关系数据库采用关系模型，具有丰富的数据类型和存储方式。HBase则采用了更加简单的数据模型，它把数据存储为未经解释的字符串，用户可以把不同格式的结构化数据和非结构化数据都序列化成字符串保存到HBase中，用户需要自己编写程序把字符申解析成不同的数据类型。

2. **数据操作**：关系数据库中包含了丰富的操作，如插入、删除、更新、查询等，其中会涉及复杂的多表连接，通常是借助于多个表之间的主外键关联来实现的。HBase操作则不存在复杂的表与表之间的关系，只有简单的插入、查询、删除、清空等，因为HBase在设计上就避免了复杂的表与表之间的关系，通常只采用单表的主键查询，所以它无法实现像关系数据库中那样的表与表之间的连接操作。

3. **存储模式**：关系数据是基于行模式存储的，元组或行会被连续地存储在磁盘页中。在读取数据时，需要顺序扫描每个元组，然后从中筛选出查询所需要的属性。如果每个元组只有少量属性的值对于查询是有用的，那么基于行模式存储就会浪费许多磁盘空间和内存带宽。HBase是基于列存储的，每个列族都由几个文件保存，不同列族的文件是分离的，它的优点是：可以降低I/O开销，支持大量并发用户查询，因为仅需要处理可以回答这些查询的列，而不需要处理与查询无关的大量数据行；同一个列族中的数据会被一起进行压缩，由于同一列族内的数据相似度较高，因此可以获得较高的数据压缩比。

4. **数据索引**：关系数据库通常可以针对不同列构建复杂的多个索引，以提高数据访问性能。与关系数据库不同的是，HBase只有一个索引–行键，通过巧妙的设计，HBase中的所有访问方法，或者通过行键访问，或者通过行键扫描，从而使得整个系统不会慢下来。由于HBase位于Hadoop框架之上，因此可以使用HadoopMapReduce来快速、高效地生成索引表。

5. **数据维护**：在关系数据库中，更新操作会用最新的当前值去替换记录中原来的旧值，旧值被覆盖后就不会存在。而在HBase中执行更新操作时，并不会删除数据旧的版本，而是生成一个新的版本，旧有的版本仍然保留。

6. **可伸缩性**：关系数据库很难实现横向扩展，纵向扩展的空间也比较有限。相反，HBase和BigTable这些分布式数据库就是为了实现灵活的水平扩展而开发的，因此能够轻易地通过在集群中增加或者减少硬件数量来实现性能的伸缩。

但是，相对于关系数据库来说，HBase也有自身的局限性，如HBase不支持事务，因此无法实现跨行的原子性。

## 4.3 HBase数据模型

### （一）HBase列族数据模型包括：

列族、列限定符、单元格、时间戳等概念

1. **表**
   - HBase采用表来组织数据、表由行和列组成，列划分为若干个列族。

2. **行**
   - 每个HBase表都由若干行组成，每个行由行键(Row Key)来标识。访问表中的行只有3种方式:通过单个行键访问;通过一个行键的区间来访问;全表扫描。行键可以是任意字符串(最大长度是64KB，实际应用中长度一般为10~100字节)，在HBase内部，行键保存为字节数组。存储时，数据按照行键的字典序排序存储。在设计行键时，要充分考虑这个特性，将经常一起读取的行存储在一起。

3. **列族**
   - 一个HBase表被分组成许多"列族"的集合，它是基本的访问控制单元。列族需要在表创建时就定义好，数量不能太多(HBase的一些缺陷使得列族数量只限于几十个)，而且不要频繁修改。存储在一个列族当中的所有数据，通常都属于同一种数据类型，这通常意味着具有更高的压缩率。表中的每个列都归属于某个列族，数据可以被存放到列族的某个列下面，但是在把数据存放到这个列族的某个列下面之前，必须首先创建这个列族。在创建完成一个列族以后，就可以使用同一个列族当中的列。列名都以列族作为前缀。例如，courses:history和courses：math这两个都属于courses这个列族。在HBase中，访问控制、磁盘和内存的使用统计都是在列族层面进行的，实际应用中，我们可以借助列族上的控制权限帮助实现特定的目的。比如，我们可以允许一些应用能够向表中添加新的数据，而另一些应用则只允许浏览数据。HBase列族还可以被配置成支持不同类型的访问模式。比如，一个列族也可以被设置成放入内存当中，以消耗内存为代价，从面换取更好的响应性能。

4. **列限定符**
   - 列族里的数据通过列限定符(或列)来定位。列限定符不用事先定义，也不需要在不同行之间保持一致。列限定符没有数据类型，总被视为字节数组byte[]。

5. **单元格**
   - 在HBase表中，通过行、列族和列限定符确定一个"单元格"(Cell)。单元格中存储的数据没有数据类型，总被视为字节数组byte[]。每个单元格中可以保存一个数据的多个版本，每个版本对应一个不同的时间戳。

6. **时间戳**
   - 每个单元格都保存着同一份数据的多个版本，这些版本采用时间戳进行索引。每次对一个单元格执行操作(新建、修改、删除)时，HBase都会隐式地自动生成并存储一个时间戳。时间戳一般是64位整型，可以由用户自己赋值(自己生成唯一时间戳可以避免应用程序中出现数据版本冲突)，也可以由HBase在数据写入时自动赋值。一个单元格的不同版本是根据时间截降序的顺序进行存储的，这样，最新的版本可以被最先读取。

### （二）数据坐标：

HBase视为一个四维坐标，即[行键，列族，列限定符，时间戳]。

### （三）面向列的储存:

简单地说，行式数据库使用NSM(N-aryStorageModel)存储模型，一个元组(或行)会被连续地存储在磁盘页中，也就是说，数据是一行一行被存储的，第一行写入磁盘页后，再继续写入第二行，依此类推。在从磁盘中读取数据时，需要从磁盘中顺序扫描每个元组的完整内容，然后从每个元组中筛选出查询所需要的属性。如果每个元组只有少量属性的值对于查询是有用的，那么NSM就会浪费许多磁盘空间和内存带宽。

### （四）行数据库和列数据库的优缺点：

行式数据库主要适用于小批量的数据处理，如联机事务性数据处理，我们平时熟悉的Oracle和MySQL等关系数据库都属于行式数据库。列数据库主要适用于批量数据处理和即席查询。它的优点是可以降低I/O开销，支持大量并发用户查询，其数据处理速度比传统方法快100倍，具有较高的数据压缩比，较传统的行式数据库更加有效，甚至能达到五倍的效果。列式数据库主要用于数据挖掘、决策支持和地理信息系统等查询密集型系统中，因为一次查询就可以得出结果而不是每次都要遍历所有的数据库。

## 4.4 HBase实现原理

### （一）HBase的实现主要包括三个组件：

库函数，链接到每个客户端、master主服务器、多个Region服务器

### （二）（重点）Region的定位HBase的三层结构

（内容待补充）

### （三）HBase的系统架构

包括客户端、Zookeeper服务器、Master主服务器、Region