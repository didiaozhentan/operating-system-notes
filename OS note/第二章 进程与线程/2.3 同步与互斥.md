# 2.3.1基本概念
## 临界资源
一次只能为一个进程所用的资源称为临界资源。很多物理设备都是临界资源，如打印机；许多变量、数据被若干进程共享，也是临界资源。

对于临界资源的访问必须互斥的进行
- 进入区：相当于上锁，设置正在访问临界区的标志
- 临界区：实际访问临界资源的代码，也称临界段
- 退出区：相当于解锁，将正在访问临界区的标志清除
- 剩余区：代码的其余部分
![[Pasted image 20250411222346.png

同步也称*直接制约关系*，互斥也称*间接制约关系*

实现临界区互斥的准则（为了禁止两个进程同时进入临界区）：
- 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
- 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
- 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区，防止进程无限等待。
- 让权等待(原则上应该遵循，但非必须)。当进程不能进入临界区时，应立即释放处理器,防止进程忙等待。

# 2.3.2进程互斥的基本方法

## 软件实现方法
### 单标志法
算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。
也就是说每个进程进入临界区的权限只能被另一个进程赋予 
主要问题：p1要访问的话，必须p0先访问，也即两个进程必须交替访问临界区。违背：*空闲让进原则*
eg.若P<sub>0</sub>顺利进入临界区并从临界区离开，则此时临界区是空闲的，但P<sub>1</sub>并没有进入临界区的打算，而turn=1一直成立，则P<sub>0</sub>就无法再次进入临界区。
```c
int turn = 0;    //逻辑是表示谦让
// 进程 P0
while (turn != 0); // 进入区
critical_section;   // 临界区
turn = 1;           // 退出区
remainder_section;  // 剩余区

// 进程 P1
while (turn != 1);  // 进入区
critical_section;   // 临界区
turn = 0;           // 退出区
remainder_section;  // 剩余区
```

### 双标志先检查法（先检查后上锁）
算法思想：设置一个bool数组flag[]来标记自己是否想要进入临界区的意愿
主要问题：由于进程是并发进行的，有可能违背：*忙则等待原则*
原因：进入区的*检查*和*上锁*并不是一气呵成的，检查之后上锁之前可能发生进程切换
eg.按序列1234执行时，即检查对方标志后和设置自己的标志前可能发生进程切换，结果双方都检查通过，都进入临界区。
```c
bool flag[2];    //逻辑是表达意愿
flag[0] = false;
flag[1] = false;
// 进程 P0
while (flag[1]);    // 1 进入区：等待 P1 完成临界区
flag[0] = true;     // 3 进入区：P0 准备进入临界区
critical_section;   // 临界区：P0 访问共享资源
flag[0] = false;    // 退出区：P0 完成临界区
remainder_section;  // 剩余区：P0 继续执行其他任务

// 进程 P1
while (flag[0]);    // 2 进入区：等待 P0 完成临界区
flag[1] = true;     // 4 进入区：P1 准备进入临界区
critical_section;   // 临界区：P1 访问共享资源
flag[1] = false;    // 退出区：P1 完成临界区
remainder_section;  // 剩余区：P1 继续执行其他任务
```

### 双标志后检查法（先上锁后检查）
算法思想：设置一个bool数组flag[]来标记自己是否想要进入临界区的意愿,不过是先上锁后检查
主要问题：由于进程是并发进行的，可能会两个同时上锁，都进不去，违反：*空闲让进*、*有限等待*，可能导致*饥饿*
eg.按序列1234执行时，即两个进程依次设置自己的标志，并依次检查对方的标志，发现对方也想进入临界区，双方都争着进入临界区，但谁都进不了
```c
bool flag[2];    //逻辑是表达意愿
flag[0] = false;
flag[1] = false;
// 进程 P0
flag[0] = true;     // 1 设置标志位，表示 P0 准备进入临界区
while (flag[1]);    // 3 进入区：等待 P1 完成临界区
critical_section;   // 临界区：P0 访问共享资源
flag[0] = false;    // 退出区：P0 完成临界区
remainder_section;  // 剩余区：P0 继续执行其他任务

// 进程 P1
flag[1] = true;     // 2 设置标志位，表示 P1 准备进入临界区
while (flag[0]);    // 4 进入区：等待 P0 完成临界区
critical_section;   // 临界区：P1 访问共享资源
flag[1] = false;    // 退出区：P1 完成临界区
remainder_section;  // 剩余区：P1 继续执行其他任务
```

### Peterson算法
算法思想：结合单双标志法的思想，有谦让的过程
遵循空闲让进、忙则等待、有限等待。但是未遵循*让权等待*，会发生*忙等*
```c
bool flag[2];   //逻辑是表达意愿
int turn = 0;   //逻辑是表示谦让

// 进程 P0
flag[0] = true;     // 进入区：设置标志位，表示 P0 准备进入临界区
turn = 1;           // 进入区：表示可以优先让P1进入
while (flag[1] && turn == 1); // 进入区：等待 P1 完成临界区
critical_section;   // 临界区：P0 访问共享资源
flag[0] = false;    // 退出区：P0 完成临界区
remainder_section;  // 剩余区：P0 继续执行其他任务

// 进程 P1
flag[1] = true;     // 进入区：设置标志位，表示 P1 准备进入临界区
turn = 0;           // 进入区：表示可以优先让P0进入
while (flag[0] && turn == 0); // 进入区：等待 P0 完成临界区
critical_section;   // 临界区：P1 访问共享资源
flag[1] = false;    // 退出区：P1 完成临界区
remainder_section;  // 剩余区：P1 继续执行其他任务
```

## 硬件实现方法
### 中断屏蔽方法
```
关中断（不允许进程中断）
临界区
开中断
```

优点：简单，高效
缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程
因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险

### TestAndSet（TSL指令）

TSL是用硬件实现的，上锁、检查一气呵成，执行过程不允许被中断
优点：实现简单，无需严格检查逻辑漏洞；适用于多处理机环境
缺点：不满足*让权等待*，会*忙等*
```c
// 布尔型共享变量 lock 表示当前临界区是否被加锁
// true 表示已加锁，false 表示未加锁
bool TestAndSet (bool *lock) {
    bool old;
    old = *lock;    // old用来存放lock原来的值
    *lock = true;   // 无论之前是否已加锁，都将lock设为true
    return old;     // 返回lock原来的值
}

// 以下是使用 TSL 指令实现互斥的算法逻辑
while (TestAndSet (&lock)); // “上锁”并“检查”
临界区代码段...
lock = false;              // “解锁”
剩余区代码段...
```

### Swap指令（逻辑类似TSL）
别称：Exchange指令、XCHG指令
Swap指令是用硬件实现的，执行过程不允许被中断，一气呵成
优点：实现简单，无需严格检查逻辑漏洞；适用于多处理机环境
缺点：不满足*让权等待*，会*忙等*
```c
// Swap 指令的作用是交换两个变量的值
Swap (bool *a, bool *b) {
    bool temp;
    temp = *a;
    *a = *b;
    *b = temp;
}

// 以下是用 Swap 指令实现互斥的算法逻辑
// lock 表示当前临界区是否被加锁
bool old = true;
while (old == true)
    Swap (&lock, &old);
临界区代码段...
lock = false;
剩余区代码段...
```


# 2.3.3互斥锁
```c
acquire(){    // 获得锁的定义
    while(!available)       // 忙等待
        ;
    available=false;        // 获得锁
}
release(){    // 释放锁的定义
    available=true;         // 释放锁
}
```
acquire()或release()的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现

# 2.3.4信号量
信号量是一种变量，表示系统中某种资源的数量
一对原语：wait（S）原语和signal（S）原语，分别简称P（S）、V（S）

## 整型信号量
用一个整数表示系统资源的变量，用来表示系统中某种资源的数量
```c
int S = 1;
wait(S) {                // 相当于进入区
    while (S <= 0);      // 若资源数不够，则一直循环等待
    S = S - 1;           // 若资源数够，则占用一个资源
}

signal(S) {             // 相当于退出区
    S = S + 1;          // 使用完后，就释放一个资源
}
```
只要S<= 0，就会循环测试，未遵循*让权等待*，可能会出现忙等

## 记录型信号量
记录型数据结构表示的信号量
```c
typedef struct{
	int value;  //剩余资源数
	struct process *L;  //等待队列
} semaphore;

//某进程需要使用资源时，通过 wait 原语申请
void wait (semaphore S) {
    S.value--;          // 信号量的值减1
    if (S.value < 0) {  // 如果信号量的值小于0
        block (S.L);    // 进程阻塞，进入等待队列
    }
}

//进程使用完资源后，通过 signal 原语释放
void signal (semaphore S) {
    s.value++;          // 信号量的值加1
    if (S.value <= 0) { // 如果信号量的值小于等于0
        wakeup(S.L);    // 唤醒等待队列中的进程
    }
}
```
除非特别说明，否则默认S为记录型信号量，该方法遵循*让权等待*
## 利用信号量实现进程互斥
## 利用信号量实现同步
## 利用信号量实现前驱关系