# 2.4.1死锁的概念
## 什么是死锁
各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。
## 进程死锁、饥饿、死循环的区别
- 死锁：
	定义：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。
	区别：至少两个或两个的进程同时发生死锁
- 饥饿：
	定义：由于长期得不到想要的资源，某进程无法向前推进的现象。
	区别：可能只有一个进程发生饥饿
- 死循环：
	定义：某进程执行过程中一直跳不出某个循环的现象。
	区别：死循环是程序员的问题
![[Pasted image 20250416102957.png]]
## 死锁产生的必要条件
- 互斥条件：多个进程争夺必须互斥使用的资源才会发生死锁
- 不剥夺条件：进程获得的资源在未使用完，不能由其它进程强行抢夺
- 请求和保持条件：某个进程有了资源，还在请求资源但被阻塞而不妨已有资源
- 循环等待条件：存在资源的循环等待链，当前已获得的资源被下一个所请求
*死锁一定循环等待，但循环等待未必死锁*
## 什么时候会发生死锁
- 对系统资源的竞争：对不可剥夺的（如打印机）竞争有死锁，对可剥夺的（如CPU）竞争不会引起死锁
- 进程推进顺序非法：请求和释放资源顺序不当，导致申请的资源依然被占用而阻塞，发生死锁
- 信号量的使用不当也会造成死锁：互斥/同步信号量也是一种资源，P/V操作不当会导致死锁

## 死锁的处理策略

- 预防死锁：破坏死锁产生的必要条件中的一个/几个
- 避免死锁：用方法防止系统进入不安全状态，如银行家算法
- 死锁的检测和解除：运行死锁发生，但会检测并采取措施解除

# 2.4.2预防死锁
## 破坏互斥条件
- 把互斥的资源改造为共享资源，例如SPOOLing技术将打印机变成共享资源
- 缺点：为了系统安全，很多地方需要保护互斥性，所以无法破坏呼出条件
## 破坏不剥夺条件
- 方案1：当请求得不到满足的时候，立即释放手里的资源
- 方案2：由系统介入，强行帮助剥夺
- 缺点：实现起来复杂，造成之前工作失效，降低系统开销，会全部放弃，导致饥饿
## 破坏请求和保持条件
- 采用静态分配方法，一次性全部申请，如果申请不到就不运行，一旦运行就不请求别的资源
- 缺点：有些资源只偶尔使用但被一直占有，导致资源利用率极低，也可能会导致某些进程饥饿
## 破坏循环等待条件
- 顺序资源分配法：对资源编号，进程按编号递增顺序请求资源
- 缺点：不方便增加新的设备，实际使用与递增顺序不一致，会导致资源的浪费，必须按规定次序申请资源
2、允许死锁发生

- 死锁的检测和解除

# 2.4.3避免死锁
动态检测：避免死锁

- 什么是安全序列
- 进行后面的某些情况，不会使系统发生死锁
- 什么是系统的不安全状态，与死锁有何联系
- 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁（处于不安全状态未必就是发生了死锁，但发生死锁时一定时在不安全状态）
- 如何避免系统进入不安全状态——银行家算法
- 初始分配完成后，优先全部分配给最少的，并且拿回资源

步骤：

1、检查此次申请是否超过了之前声明的最大需求数

2、检查此时系统剩余的可用资源是否还能满足这次请求

3、试探着分配，更改各数据结构

4、用安全性算法检查此次所分配是否会导致系统进入不安全状态
# 2.4.4检测和解除
死锁的检测

1、用某种数据结构来保存资源的请求和分配信息

2、提供一种算法，利用上述信息来检测系统是否已进入死锁状态

死锁的解除

1、资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。

2、撤销进程法：强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。

3、进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。