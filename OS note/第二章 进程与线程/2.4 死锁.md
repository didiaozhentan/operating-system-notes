# 2.4.1死锁的概念
## 什么是死锁
各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。
## 进程死锁、饥饿、死循环的区别
- 死锁：
	定义：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象。
	区别：至少两个或两个的进程同时发生死锁
- 饥饿：
	定义：由于长期得不到想要的资源，某进程无法向前推进的现象。
	区别：可能只有一个进程发生饥饿
- 死循环：
	定义：某进程执行过程中一直跳不出某个循环的现象。
	区别：死循环是程序员的问题
![[Pasted image 20250416102957.png]]
## 死锁产生的必要条件
- 互斥条件：多个进程争夺必须互斥使用的资源才会发生死锁
- 不剥夺条件：进程获得的资源在未使用完，不能由其它进程强行抢夺
- 请求和保持条件：某个进程有了资源，还在请求资源但被阻塞而不妨已有资源
- 循环等待条件：存在资源的循环等待链，当前已获得的资源被下一个所请求
*死锁一定循环等待，但循环等待未必死锁*
![[Pasted image 20250419125634.png]]
## 什么时候会发生死锁
- 对系统资源的竞争：对不可剥夺的（如打印机）竞争有死锁，对可剥夺的（如CPU）竞争不会引起死锁
- 进程推进顺序非法：请求和释放资源顺序不当，导致申请的资源依然被占用而阻塞，发生死锁
- 信号量的使用不当也会造成死锁：互斥/同步信号量也是一种资源，P/V操作不当会导致死锁

## 死锁的处理策略

- 预防死锁：破坏死锁产生的必要条件中的一个/几个
- 避免死锁：用方法防止系统进入不安全状态，如银行家算法
- 死锁的检测和解除：运行死锁发生，但会检测并采取措施解除

![[Pasted image 20250419125713.png]]
# 2.4.2预防死锁
## 破坏互斥条件
- 把互斥的资源改造为共享资源，例如SPOOLing技术将打印机变成共享资源
- 缺点：为了系统安全，很多地方需要保护互斥性，所以无法破坏呼出条件
## 破坏不剥夺条件
- 方案1：当请求得不到满足的时候，立即释放手里的资源
- 方案2：由系统介入，强行帮助剥夺
- 缺点：实现起来复杂，造成之前工作失效，降低系统开销，会全部放弃，导致饥饿
## 破坏请求和保持条件
- 采用静态分配方法，一次性全部申请，如果申请不到就不运行，一旦运行就不请求别的资源
- 缺点：有些资源只偶尔使用但被一直占有，导致资源利用率极低，也可能会导致某些进程饥饿
## 破坏循环等待条件
- 顺序资源分配法：对资源编号，进程按编号递增顺序请求资源
- 缺点：不方便增加新的设备，实际使用与递增顺序不一致，会导致资源的浪费，必须按规定次序申请资源

# 2.4.3避免死锁
## 什么是安全序列
指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是*安全状态*。当然，安全序列可能有多个。
## 什么是系统的不安全状态
- 如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁
- 处于不安全状态未必就是发生了死锁，但发生死锁时一定时在不安全状态
- 如何避免系统进入不安全状态——银行家算法
- 初始分配完成后，优先全部分配给最少的，并且拿回资源

## 银行家算法步骤
1. 检查此次申请是否超过了之前声明的最大需求数
2. 检查此时系统剩余的可用资源是否还能满足这次请求
3. 试探着分配，更改各数据结构
4. 用安全性算法检查此次所分配是否会导致系统进入不安全状态

假设系统中有n个进程，m种资源每个进程在运行前先声明对各种资源的最大需求数则可用一个n\*m的矩阵(可用二维数组实现)表示所有进程对各种资源的最大需求数。不妨称为*最大需求矩阵 Max*，Max[i,j]=K表示进程Pi最多需要K个资源Rj。同理，系统可以用一个n\*m的*分配矩阵Allocation*表示对所有进程的资源分配情况。Max-Allocation=*Need 矩阵*，表示各进程最多还需要多少各类资源。另外，还要用一个长度为m的一维数组 Available 表示当前系统中还有多少可用资源。
![[Pasted image 20250416114445.png]]
![[Pasted image 20250416114606.png]]
![[Pasted image 20250419130951.png]]
## 安全性算法步骤:
- 检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列,并把该进程持有的资源全部回收。
- 不断重复上述过程，看最终是否能让所有进程都加入安全序列。
# 2.4.4检测和解除
## 死锁的检测的前提：
- 用某种数据结构来保存资源的请求和分配信息
-  提供一种算法，利用上述信息来检测系统是否已进入死锁状态
## 检测死锁的算法：
-  在资源分配图中，找出既不阻塞又不是孤点的进程Pi，消去它所有的请求边和分配变，使之称为孤立的结点。
- 进程 Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。
- 进行一系列简化后，若能消去途中所有的边，则称该图是可*完全简化*的。如果某时刻系统的资源分配图是*不可完全简化*的，那么此时系统*死锁*。
![[Pasted image 20250417150954.png]]
## 死锁的解除：
- 资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。
- 撤销进程法：强制撤销部分，甚至全部死锁进程，并剥夺这些进程的资源。代价很大，进程需要从头再来。
- 进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步。要记录进程的历史信息，设置还原点。
## 如何决定方法：
- 进程优先级
- 已执行多长时间
- 还要多久能完成
- 进程已经使用了多少资源
- 进程是交互式的还是批处理式的