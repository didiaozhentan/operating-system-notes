### 3.1   什么是指令跟踪？

指令跟踪是指为该进程而执行的指令序列。

### 3.2   通常那些事件会导致创建一个进程？

新的批处理作业；交互登录；操作系统因为提供一项服务而创建；由现有的进程派生。（表3.1）

### 3.3   对于图3.6中的进程模型，请简单定义每个状态。

运行态：该进程正在执行。就绪态：进程做好了准备，只要有机会就开始执行。

阻塞态：进程在某些事件发生前不能执行，如I/O操作完成。

新建态：刚刚创建的进程，操作系统还没有把它加入到可执行进程组中。

退出态：操作系统从可执行进程组中释放出的进程，或者是因为它自身停止了，或者是因为某种原因被取消。

### 3.4   抢占一个进程是什么意思？

处理器为了执行另外的进程而终止当前正在执行的进程，这就叫进程抢占。

### 3.5   什么是交换，其目的是什么？

交换是指把主存中某个进程的一部分或者全部内容转移到磁盘。当主存中没有处于就绪态的进程时，操作系统就把一个阻塞的进程换出到磁盘中的挂起队列，从而使另一个进程可以进入主存执行。

### 3.6   为什么图3.9（b）中有两个阻塞态？

有两个独立的概念：进程是否在等待一个事件（阻塞与否）以及进程是否已经被换出主存（挂起与否）。为适应这种2\*2的组合，需要两个阻塞态和两个挂起态。

### 3.7   列出挂起态进程的4个特点。

1.进程不能立即执行。

2.进程可能是或不是正在等待一个事件。如果是，阻塞条件不依赖于挂起条件，阻塞事件的发生不会使进程立即被执行。

3.为了阻止进程执行，可以通过代理把这个进程置于挂起态，代理可以是进程自己，也可以是父进程或操作系统。

4.除非代理显式地命令系统进行状态转换，否则进程无法从这个状态中转移。

### 3.8   对于哪类实体，操作系统为了管理它而维护其信息表？

内存、I/O、文件和进程。

### 3.9   列出进程控制块中的三类信息。

进程标识，处理器状态信息，进程控制信息。

### 3.10 为什么需要两种模式（用户模式和内核模式）？

用户模式下可以执行的指令和访问的内存区域都受到限制。这是为了防止操作系统受到破坏或者修改。而在内核模式下则没有这些限制，从而使它能够完成其功能。

### 3.11 操作系统创建一个新进程所执行的步骤是什么？

1.给新进程分配一个唯一的进程标识号。
2.给进程分配空间。
3.初始化进程控制块。
4.设置正确的连接。
5.创建或扩充其他的数据结构。

### 3.12 中断和陷阱有什么区别？

中断与当前正在运行的进程无关的某些类型的外部事件相关，如完成一次I/O操作。
陷阱与当前正在运行的进程所产生的错误或异常条件相关，如非法的文件访问。

### 3.13 举出中断的三个例子。

时钟终端，I/O终端，内存失效。

### 3.14 模式切换和进程切换有什么区别？

发生模式切换可以不改变当前正处于运行态的进程的状态。发生进程切换时，一个正在执行的进程被中断，操作系统指定另一个进程为运行态。进程切换需要保存更多的状态信息。

### 4.1 表3.5列出了在一个没有线程的操作系统中进程控制块的基本元素。对于多线程系统，这些元素中那些可能属于线程控制块，那些可能属于进程控制块？

这对于不同的系统来说通常是不同的，但一般来说，进程是资源的所有者，而每个线程都有它自己的执行状态。关于表3.5中的每一项的一些结论如下：进程标识：进程必须被标识，而进程中的每一个线程也必须有自己的ID。处理器状态信息：这些信息通常只与进程有关。进程控制信息：调度和状态信息主要处于线程级；数据结构在两级都可出现；进程间通信和线程间通信都可以得到支持；特权在两级都可以存在；存储管理通常在进程级；资源信息通常也在进程级。

### 4.2 请列出线程间的模式切换比进程间的模式切换开销更低的原因。

包含的状态信息更少。

### 4.3 在进程概念中体现出的两个独立且无关的特点是什么？

资源所有权和调度/执行。

### 4.4 给出在单用户多处理系统中使用线程的四个例子。

前台和后台操作，异步处理，加速执行和模块化程序结构。

### 4.5 哪些资源通常被一个进程中的所有线程共享？

例如地址空间，文件资源，执行特权等。

### 4.6 列出用户级线程优于内核级线程的三个优点。

1.由于所有线程管理数据结构都在一个进程的用户地址空间中，线程切换不需要内核模式的特权，因此，进程不需要为了线程管理而切换到内核模式，这节省了在两种模式间进行切换（从用户模式到内核模式；从内核模式返回用户模式）的开销。

2.调用可以是应用程序专用的。一个应用程序可能倾向于简单的轮询调度算法，而另一个应用程序可能倾向于基于优先级的调度算法。调度算法可以去适应应用程序，而不会扰乱底层的操作系统调度器。

3.用户级线程可以在任何操作系统中运行，不需要对底层内核进行修改以支持用户级线程。线程库是一组供所有应用程序共享的应用级软件包。

### 4.7 列出用户级线程相对于内核级线程的两个缺点。

1.在典型的操作系统中，许多系统调用都会引起阻塞。因此，当用户级线程执行一个系统调用时，不仅这个线程会被阻塞，进程中的所有线程都会被阻塞。

2.在纯粹的用户级进程策略中，一个多线程应用程序不能利用多处理技术。内核一次只把一个进程分配给一个处理器，因此一次进程中只能有一个线程可以执行。

### 4.8 定义jacketing。

Jacketing通过调用一个应用级的I/O例程来检查I/O设备的状态，从而将一个产生阻塞的系统调用转化为一个不产生阻塞的系统调用。

### 4.9 简单定义图4.8中列出的各种结构。

SIMD：一个机器指令控制许多处理部件步伐一致地同时执行。每个处理部件都有一个相关的数据存储空间，因此，每条指令由不同的处理器在不同的数据集合上执行。

MIMD：一组处理器同时在不同的数据集上执行不同的指令序列。主/从：操作系统内核总是在某个特定的处理器上运行，其他处理器只用于执行用户程序，还可能执行一些操作系统实用程序。

SMP：内核可以在任何处理器上执行，并且通常是每个处理器从可用的进程或线程池中进行各自的调度工作。集群：每个处理器都有一个专用存储器，而且每个处理部件都是一个独立的计算机。

### 4.10 列出SMP操作系统的主要设计问题。

同时的并发进程或线程，调度，同步，存储器管理，可靠性和容错。

### 4.11 给出在典型的单体结构操作系统中可以找到且可能是微内核操作系统外部子系统中的服务和功能。

设备驱动程序，文件系统，虚存管理程序，窗口系统和安全服务。

### 4.12 列出并简单解释微内核设计相对于整体式设计的七个优点。

一致接口：进程不需要区分是内核级服务还是用户级服务，因为所有服务都是通过消息传递提供的。

可扩展性：允许增加新的服务以及在同一个功能区域中提供多个服务。

灵活性：不仅可以在操作系统中增加新功能，还可以删减现有的功能，以产生一个更小、更有效的实现。

可移植性：所有或者至少大部分处理器专用代码都在微内核中。因此，当把系统移植到一个处理器上时只需要很少的变化，而且易于进行逻辑上的归类。

可靠性：小的微内核可以被严格地测试，它使用少量的应用程序编程接口（API），这就为内核外部的操作系统服务产生高质量的代码提供了机会。

分布式系统支持：微内核通信中消息的方向性决定了它对分布式系统的支持。

面向对象操作系统环境：在微内核设计和操作系统模块化扩展的开发中都可以借助面向对象方法的原理。

### 4.13 解释微内核操作系统可能存在的性能缺点。

通过微内核构造和发送信息、接受应答并解码所花费的时间比一次系统调用的时间要多。

### 4.14 列出即使在最小的微内核操作系统中也可以找到的三个功能。

低级存储器管理，进程间通信（IPC）以及I/O和中断管理。

### 4.15 在微内核操作系统中，进程或线程间通信的基本形式是什么？

消息。

### 5.1 列出与并发相关的四种设计问题

进程间的交互，共享资源之间的竞争，多个进程的同步问题，对进程的处理器时间分配问题

### 5.2 列出并发的三种上下文

多个应用程序，结构化应用程序，操作系统结构

### 5.3 执行并发进程的最基本要求是什么？

加强互斥的能力

### 5.4 列出进程间的三种互相知道的程度，并简单地给出各自的定义。

进程间互相不知道对方：这是一些独立的进程，他们不会一起工作。

进程间间接知道对方：这些进程并不需要知道对方的进程ID号，但他们共享访问某些对象，如一个I/O缓冲区。

进程间直接知道对方：这些进程可以通过进程ID号互相通信，用于合作完成某些活动。

### 5.5 竞争进程和合作进程进程间有什么区别。

竞争进程需要同时访问相同的资源，像磁盘，文件或打印机。合作进程要么共享访问一个共有的资源，像一个内存访问区，要么就与其他进程相互通信，在一些应用程序或活动上进行合作。

### 5.6 列出与竞争进程相关的三种控制问题，并简单地给出各自的定义。

互斥：竞争进程仅可以访问一个临界资源（一次仅有一个进程可以访问临界资源），并发机制必须满足一次只有一个进程可以访问临界资源这个规则。

死锁：如果竞争进程需要唯一的访问多于一个资源，并且当一个进程控制着一个进程，且在等待另一个进程，死锁可能发生。

饥饿：一组进程的一个可能会无限期地拒绝进入到一个需要资源，因为其他

成员组成垄断这个资源。

### 5.7 列出对互斥的要求。

1.必须强制实施互斥：在具有关于相同资源或共享对象的临界区的所有进程中，一次只允许一个进程进入临界区。

2.一个在临界区停止的进程必须不干涉其他进程。

3.绝不允许出现一个需要访问临界区的进程被无限延迟的情况，即不会饿死或饥饿。

4.当没有进程在临界区中时，任何需要进入临界区的进程必须能够立即进入。

5.对相关进程的速度和处理器的数目没有任何要求和限制。

6.一个进程驻留在临界区中的时间是有限的。

### 5.8 在信号量上可以执行什么操作。

1.一个信号量可以初始化成非负数。

2.wait操作使信号量减1，如果值为负数，那么进程执行wait就会受阻。3signal操作使信号量增加1，如果小于或等于0，则被wait操作阻塞的进程被解除阻塞。

5.9 二元信号量与一般信号量有什么区别。

二元信号量只能取0或1，而一般信号量可以取任何整数。

5.10 强信号量与弱信号量有什么区别。

强信号量要求在信号量上等待的进程按照先进先出的规则从队列中移出。弱信号量没有此规则。

5.11 .什么是管程。

管程是由一个或多个过程，一个初始化序列和局部数据组成的软件模块。

5.12 对于消息，有阻塞和无阻塞有什么区别？

   发送者和接收者任一方阻塞则消息传递需要等待，都无阻塞则不需等待。

5.13 通常与读者-写者问题相关联的有哪些条件？

1.任意多的读进程可以同时读这个文件

2.一次只有一个写进程可以往文件中写

3.如果一个写进程正在往文件中写时，则禁止任何读进程读文件。


6.1 给出可重用资源和可消费资源的例子。

可重用资源：处理器，Ｉ/Ｏ通道，主存和辅存，设备以及诸如文件，数据库和信号量之类的数据结构。

可消费资源：中断，信号，消息和Ｉ/Ｏ缓冲区中的信息。

6.2 可能发生死锁所必须的三个条件是什么？

互斥，占有且等待，非抢占。

6.3 产生死锁的第４个条件是什么？

循环等待。

6.4 如何防止占有且等待的条件？

可以要求进程一次性地请求所有需要的资源，并且阻塞这个资源直到所有请求都同时满足。

6.5 给出防止无抢占条件的两种方法。

第一种，如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占用的资源，如果有必要，可再次请求这些资源和另外的资源。

第二种，如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。

6.6 如何防止循环等待条件？

可以通过定义资源类型的线性顺序来预防。如果一个进程已经分配到了Ｒ类型的资源，那么它接下来请求的资源只能是那些排在Ｒ类型之后的资源类型。

6.7 死锁避免，检测和预防之间的区别是什么？

死锁预防是通过间接地限制三种死锁必要条件的至少一个或是直接地限制循环等待的发生来避免死锁的出现。死锁避免允许可能出现的必要条件发生，但是采取措施确保不会出现死锁的情况。而死锁检测允许资源的自由分配，采取周期性的措施来发现并处理可能存在的死锁情况。